commit 05591bdc8a3c6a64af687db47064bc02a269f2c7
Author: Quantum AI Researcher <quantum@example.com>
Date:   Fri Dec 19 00:22:24 2025 -0500

    Add chess game mode with JSON structured output
    
    - Implement complete chess game class with legal move validation
    - Add --chess command-line parameter to enable chess mode
    - Create structured JSON output format with dialogue, move, and board state
    - Add move parsing and validation using algebraic notation
    - Implement game loop that continues until completion with draw handling
    - Add automatic game reset when draws occur
    - Include winner declaration at game end
    - Add comprehensive documentation in Chess_Game_Mode.md
    - Update character interaction system to support chess gameplay with turn-based moves
    - Add JSON parsing functions to split responses into three components
    - Warn users when using --max-turns with chess mode since games continue until completion

diff --git a/character_interactions/main.py b/character_interactions/main.py
index 62a2f0f..c0848f3 100644
--- a/character_interactions/main.py
+++ b/character_interactions/main.py
@@ -30,6 +30,7 @@ from response_generator import generate_response_adaptive
 from repitition_detector import detect_repetition_patterns
 from scenario_adapter import adapt_character_message
 from scenario_progression import ScenarioProgressor, check_scenario_progression
+from chess_game import ChessGame
 
 
 def validate_api_key(args):
@@ -61,7 +62,7 @@ def parse_arguments() -> argparse.Namespace:
     parser = argparse.ArgumentParser(
         description='Dynamic AI Character Conversation System - Anti-Repetition Enhanced'
     )
-    parser.add_argument('characters', nargs='+', 
+    parser.add_argument('characters', nargs='+',
                         help='Character JSON files (minimum 2, supports more for multi-character scenarios)')
     parser.add_argument('-o', '--output', help='Output JSON file')
     parser.add_argument('-t', '--max-turns', type=int, default=MAX_TURNS,
@@ -91,6 +92,9 @@ def parse_arguments() -> argparse.Namespace:
                         help='Resume from a saved conversation file')
     parser.add_argument('--start-turn', type=int, default=1,
                         help='Starting turn number when resuming (default: 1)')
+    # Chess game argument
+    parser.add_argument('--chess', action='store_true',
+                        help='Enable chess game mode where characters play chess and discuss moves')
     return parser.parse_args()
 
 
@@ -200,6 +204,11 @@ def main():
         api_key = validate_api_key(args)
         print("‚úì API key validated\n")
 
+        # Check for chess mode specific constraints
+        if args.chess and args.max_turns != MAX_TURNS:
+            print(f"‚ö†Ô∏è  WARNING: --max-turns parameter is not recommended in chess mode as games continue until completion")
+            print(f"   Chess games will continue until a winner is determined, regardless of turn count.")
+
         # Update global config
         import config
         config.DELAY_SECONDS = args.delay
@@ -282,98 +291,505 @@ def main():
         current_char_index = 1 if len(history) == 0 else len(history) % len(characters)
         other_char_index = 0 if len(history) == 0 else (len(history) - 1) % len(characters)
 
-        # Main conversation loop
-        for turn in range(start_turn, args.max_turns + 1):
-            print(f"\n{'='*80}")
-            print(f"[TURN {turn}] {characters[current_char_index]['name']}")
-            print('='*80)
-            
-            try:
-                # Get current and other characters
-                current_char = characters[current_char_index]
-                other_char = characters[other_char_index]
-
-                # Determine current scenario context (default to args.scenario or enhanced if progression exists)
-                current_scenario = args.scenario
-                if scenario_progressor:
-                    # Always use the latest scenario context from progressor if available
-                    current_scenario = scenario_progressor.get_scenario_context_for_stage()
-
-                # Check for scenario progression
-                scenario_progression_message = ""
-                if scenario_progressor:
-                    scenario_progression_message = check_scenario_progression(scenario_progressor, history, turn)
-                    if scenario_progression_message:
-                        print(f"üöÄ SCENARIO PROGRESSION: {scenario_progression_message}")
-                        # Add scenario progression to history as a narrative element
-                        history.append({'name': 'Narrator', 'content': scenario_progression_message})
-                        # Update the scenario context for this turn and for future turns
-                        current_scenario = scenario_progressor.get_scenario_context_for_stage()
-                        args.scenario = current_scenario  # Update the main scenario for future use
-                        print(f"üìä Updated scenario context: {scenario_progressor.get_current_stage_description()}")
-
-                # Extract lorebook entries based on scenario keywords
-                lorebook_entries = []
-                if current_scenario:  # Use current_scenario which may be updated by progression
-                    from character_loader import extract_lorebook_entries
-                    # Search for keywords in scenario that match character lorebooks
-                    scenario_keywords = current_scenario.lower().split()
-                    for char in characters:
-                        entries = extract_lorebook_entries(char['raw_data'], history, max_entries=2)
-                        # Filter entries by scenario relevance
-                        relevant_entries = []
-                        for entry in entries:
-                            if any(keyword in entry.lower() for keyword in scenario_keywords if len(keyword) > 3):
-                                relevant_entries.append(entry)
-                        lorebook_entries.extend(relevant_entries[:1])  # Add at most 1 relevant entry per character
+        # Check if we're in chess mode
+        if args.chess:
+            print("‚ôî‚ôñ‚ôó‚ôï‚ôî‚ôó‚ôñ‚ôò Playing Chess Mode Activated ‚ôò‚ôñ‚ôó‚ôî‚ôï‚ôó‚ôñ‚ôî")
+            print("=" * 80)
+
+            # In chess mode, we only support 2 characters and ignore max-turns parameter
+            if len(characters) != 2:
+                print("‚ùå Chess mode requires exactly 2 characters")
+                sys.exit(1)
+
+            # Assign players to chess colors based on order (first character is white)
+            white_player = characters[0]
+            black_player = characters[1]
+            white_player['chess_color'] = 'white'
+            black_player['chess_color'] = 'black'
+
+            # Initialize chess game
+            chess_game = ChessGame()
+            print("Initial Chess Board:")
+            print(chess_game.print_board())
+
+            # Initialize conversation history with chess context
+            chess_history = []
+
+            # Add opening chess context to history
+            opening_context = f"Starting a game of chess. {white_player['name']} is playing as white, and {black_player['name']} is playing as black."
+            chess_history.append({'name': 'Narrator', 'content': opening_context})
+            print(f"[TURN 1] Narrator: {opening_context}")
+
+            # Chess game loop
+            game_count = 1
+            turn = 1  # Main turn counter
+
+            while True:
+                print(f"\n{'='*80}")
+                print(f"CHESS GAME #{game_count}")
+                print('='*80)
+
+                # Reset chess game for each game (in case of draws)
+                chess_game = ChessGame()
+
+                # Add game start context to history
+                game_start_context = f"Starting chess game #{game_count}. {white_player['name']} (white) vs {black_player['name']} (black)."
+                chess_history.append({'name': 'Narrator', 'content': game_start_context})
+                print(f"[TURN {turn}] Narrator: {game_start_context}")
+                turn += 1
+
+                # Chess game turn counter
+                chess_turn = 1
+
+                # Start the chess game loop
+                while not chess_game.game_over:
+                    print(f"\n{'='*60}")
+                    print(f"[CHESS TURN {chess_turn}] Board Position:")
+                    print(chess_game.print_board())
+                    print(f"Move History: {' '.join(chess_game.move_history)}")
+                    print(f"Current Player: {chess_game.current_player}")
+                    print('='*60)
+
+                    # Determine who is making the move
+                    if chess_game.current_player == 'white':
+                        current_char = white_player
+                        other_char = black_player
+                    else:
+                        current_char = black_player
+                        other_char = white_player
+
+                    # Process one move for the current player
+                    move_success, turn = process_chess_move(chess_game, current_char, other_char, chess_history, turn, args, chess_game.current_player)
+
+                    if move_success:
+                        # If move was successful, increment chess turn
+                        chess_turn += 1
+                    # If move failed, we don't increment chess turn, so the same player gets another chance
+
+                    # Delay before next turn
+                    if not chess_game.game_over and turn < args.max_turns:  # We should still respect the max turns as a safety
+                        print(f"\n‚è≥ Waiting {args.delay} seconds...")
+                        time.sleep(args.delay)
+                    elif chess_game.game_over:
+                        break
+
+                # Handle game end
+                if chess_game.winner == 'draw':
+                    game_end_context = f"Game #{game_count} ended in a draw. Starting a new game..."
+                    chess_history.append({'name': 'Narrator', 'content': game_end_context})
+                    print(f"üèÜ Game #{game_count} ended in a draw. Starting a new game...")
+                    game_count += 1
+                    continue  # Continue to next game
+                else:
+                    winner_name = white_player['name'] if chess_game.winner == 'white' else black_player['name']
+                    game_end_context = f"Game #{game_count} ended. {winner_name} wins!"
+                    chess_history.append({'name': 'Narrator', 'content': game_end_context})
+                    print(f"üèÜ Game #{game_count} ended. {winner_name} wins!")
+                    print(f"Final board position:\n{chess_game.print_board()}")
+                    break  # End the overall game loop
+
+            # After chess mode, update the history variable to save properly
+            history = chess_history
+
+        # Add a helper function to extract chess moves from the AI response
+        def extract_chess_move(response_text, chess_game, current_player_color):
+            """
+            Extract a chess move from the AI's response text.
+            This function looks for standard chess notation and converts it to board coordinates.
+            """
+            import re
+
+            # Look for common chess move patterns in the response
+            # Enhanced pattern matching to extract moves from text
+            # Handle various formats like "e4", "Nf3", "exd5", "O-O", "e7e8Q" (pawn promotion), etc.
+
+            # First, try to extract source and destination squares using patterns
+            # Look for patterns like "e2 to e4", "move e2 to e4", "e2-e4", etc.
+            source_dest_pattern = r'([a-h][1-8])\s*(?:to|-)\s*([a-h][1-8])'
+            matches = re.findall(source_dest_pattern, response_text, re.IGNORECASE)
+
+            if matches:
+                for from_sq, to_sq in matches:
+                    try:
+                        # Convert algebraic to board coordinates
+                        from_col = ord(from_sq[0].lower()) - ord('a')
+                        from_row = 8 - int(from_sq[1])
+                        to_col = ord(to_sq[0].lower()) - ord('a')
+                        to_row = 8 - int(to_sq[1])
+
+                        from_pos = (from_row, from_col)
+                        to_pos = (to_row, to_col)
+
+                        # Check if this is a valid move in the current position
+                        if chess_game.is_move_legal(from_pos, to_pos, current_player_color):
+                            return from_pos, to_pos
+                    except (IndexError, ValueError):
+                        continue  # Skip invalid squares
+
+            # Next, look for standard algebraic notation (without captures marked explicitly)
+            # Pattern: piece letter (optional) + disambiguating file/rank (optional) + destination square
+            alg_pattern = r'\b([KQRBN]?[a-h]?[1-8]?[a-h][1-8])\b'
+            alg_matches = re.findall(alg_pattern, response_text)
+
+            # Filter for pure square patterns (no piece letters, just destination)
+            destination_only = [m for m in alg_matches if len(m) == 2 and m[0] in 'abcdefgh' and m[1] in '12345678']
+
+            # If we find destination squares, try to find matching source pieces
+            for dest_sq in destination_only:
+                try:
+                    dest_col = ord(dest_sq[0].lower()) - ord('a')
+                    dest_row = 8 - int(dest_sq[1])
+
+                    # Find all pieces of current player's color that can move to this destination
+                    for row in range(8):
+                        for col in range(8):
+                            piece = chess_game.get_piece_at(row, col)
+                            if piece and chess_game.is_own_piece(piece, current_player_color):
+                                # Check if this piece can move to the destination
+                                temp_moves = chess_game._get_piece_valid_moves(row, col)
+                                if (dest_row, dest_col) in temp_moves:
+                                    from_pos = (row, col)
+                                    to_pos = (dest_row, dest_col)
+
+                                    # Make sure the complete move is legal
+                                    if chess_game.is_move_legal(from_pos, to_pos, current_player_color):
+                                        return from_pos, to_pos
+                except (IndexError, ValueError):
+                    continue  # Skip invalid squares
+
+            # If we still haven't found a move, try to find any valid move from the text
+            # Look for two square references in the text
+            squares = re.findall(r'([a-h][1-8])', response_text.lower())
+            seen_squares = set()
+            unique_squares = []
+            for sq in squares:
+                if sq not in seen_squares:
+                    unique_squares.append(sq)
+                    seen_squares.add(sq)
+
+            # Try combinations of squares
+            if len(unique_squares) >= 2:
+                for i in range(len(unique_squares)):
+                    for j in range(len(unique_squares)):
+                        if i != j:
+                            from_sq = unique_squares[i]
+                            to_sq = unique_squares[j]
+
+                            try:
+                                # Convert algebraic to board coordinates
+                                from_col = ord(from_sq[0]) - ord('a')
+                                from_row = 8 - int(from_sq[1])
+                                to_col = ord(to_sq[0]) - ord('a')
+                                to_row = 8 - int(to_sq[1])
+
+                                from_pos = (from_row, from_col)
+                                to_pos = (to_row, to_col)
+
+                                # Check if this is a valid move in the current position
+                                if chess_game.is_move_legal(from_pos, to_pos, current_player_color):
+                                    return from_pos, to_pos
+                            except (IndexError, ValueError):
+                                continue  # Skip invalid squares
+
+            # If no move was found, return None
+            return None, None
+
+        def parse_chess_json_response(response_text, character_name):
+            """Parse the JSON response from the AI containing dialogue, move, and board state."""
+            import json
+            import re
+
+            # First try to find JSON within the response
+            # Look for JSON between curly braces
+            json_pattern = r'\{.*?\}'  # Non-greedy match for JSON objects
+            matches = re.findall(json_pattern, response_text, re.DOTALL)
+
+            if not matches:
+                # If no JSON found, return with None values
+                return response_text, None, None
+
+            # Try each match until one parses correctly
+            for json_str in matches:
+                try:
+                    # Remove any leading/trailing text that might interfere
+                    json_clean = json_str.strip()
+                    parsed = json.loads(json_clean)
+
+                    dialogue = parsed.get('dialogue', '')
+                    move = parsed.get('move', '').strip()
+                    board_state = parsed.get('board_state', '')
+
+                    # If we successfully parsed and have at least a move or dialogue
+                    if dialogue or move:
+                        return dialogue, move, board_state
+                except json.JSONDecodeError:
+                    continue  # Try the next match
+
+            # If no JSON could be parsed, return the original text as dialogue
+            return response_text, None, None
+
+        def parse_move_notation(move_notation, chess_game, current_player_color):
+            """Parse algebraic move notation and return the from/to positions."""
+            import re
+
+            if not move_notation:
+                return False, None, None
+
+            move_notation = move_notation.strip()
+
+            # Handle castling notation
+            if move_notation.lower() in ['o-o', '0-0']:  # Kingside castling
+                # For white: king from (7,4) to (7,6), rook from (7,7) to (7,5)
+                # For black: king from (0,4) to (0,6), rook from (0,7) to (0,5)
+                row = 7 if current_player_color == 'white' else 0
+                from_pos = (row, 4)  # King start position
+                to_pos = (row, 6)   # King end position (kingside castle)
+
+                if chess_game.is_move_legal(from_pos, to_pos, current_player_color):
+                    return True, from_pos, to_pos
+                return False, None, None
+
+            elif move_notation.lower() in ['o-o-o', '0-0-0']:  # Queenside castling
+                # For white: king from (7,4) to (7,2), rook from (7,0) to (7,3)
+                # For black: king from (0,4) to (0,2), rook from (0,0) to (0,3)
+                row = 7 if current_player_color == 'white' else 0
+                from_pos = (row, 4)  # King start position
+                to_pos = (row, 2)   # King end position (queenside castle)
+
+                if chess_game.is_move_legal(from_pos, to_pos, current_player_color):
+                    return True, from_pos, to_pos
+                return False, None, None
+
+            # Handle standard notation like: e4, Nf3, exd5, Bxf7+, etc.
+            # Extract destination square (last 2 characters that look like a square)
+            dest_match = re.search(r'([a-h][1-8])$', move_notation.lower())
+            if dest_match:
+                dest_sq = dest_match.group(1)
+                dest_col = ord(dest_sq[0]) - ord('a')
+                dest_row = 8 - int(dest_sq[1])
+                dest_pos = (dest_row, dest_col)
+
+                # If the notation is just a destination square (like 'e4'), try to find the piece that can move there
+                if len(move_notation.strip()) == 2:  # Simple notation like 'e4'
+                    # Find all pieces that can move to this destination
+                    for row in range(8):
+                        for col in range(8):
+                            piece = chess_game.get_piece_at(row, col)
+                            if piece and chess_game.is_own_piece(piece, current_player_color):
+                                # Check if this piece can move to the destination
+                                temp_moves = chess_game._get_piece_valid_moves(row, col)
+                                if dest_pos in temp_moves:
+                                    from_pos = (row, col)
+                                    if chess_game.is_move_legal(from_pos, dest_pos, current_player_color):
+                                        return True, from_pos, dest_pos
+                    return False, None, None  # No valid piece can make this move
+
+                # For more complex notation, try to extract source info
+                else:
+                    # Look for source square in the notation (e.g., "e2e4", "d7d8Q", etc.)
+                    source_match = re.search(r'([a-h][1-8]).*?([a-h][1-8])', move_notation.lower())
+                    if source_match:
+                        from_sq = source_match.group(1)
+                        to_sq = source_match.group(2)  # Should match dest_sq
+
+                        from_col = ord(from_sq[0]) - ord('a')
+                        from_row = 8 - int(from_sq[1])
+                        from_pos = (from_row, from_col)
+
+                        if chess_game.is_move_legal(from_pos, dest_pos, current_player_color):
+                            return True, from_pos, dest_pos
+
+            # If we couldn't parse it, return failure
+            return False, None, None
+
+
+        # Chess move processing function
+        def process_chess_move(chess_game, current_char, other_char, chess_history, turn, args, current_player_color):
+            """Process a single chess move by the current player."""
+            print(f"\n[TURN {turn}] {current_char['name']} (playing as {current_player_color})")
 
+            try:
+                # Create chess context for the turn, requesting JSON output
+                chess_context = f"""
+Chess Game Context:
+- Current Board Position:
+{chess_game.print_board()}
+
+- Move History: {' '.join(chess_game.move_history)}
+- Current Player: {chess_game.current_player}
+- Your color: {current_char['chess_color']}
+
+You are playing chess. It's your turn to make a move. Please respond in the following JSON format:
+{{
+  "dialogue": "Your dialogue and thought process about the chess position",
+  "move": "The chess move in algebraic notation (e.g., 'e4', 'Nf3', 'O-O', 'exd5', etc.)",
+  "board_state": "A visual representation of the board after your move (only include if this is your move)"
+}}
+
+Make sure your move is legal in the current position. Think through your strategy before responding.
+                """.strip()
+
+                # Generate response with chess context
                 resp = generate_response_adaptive(
-                    current_char, other_char, history, turn,
+                    current_char, other_char, chess_history, turn,
                     enable_environmental=not args.no_environmental,
                     similarity_threshold=args.similarity,
                     verbose=args.verbose,
-                    scenario_context=current_scenario,
-                    lorebook_entries=lorebook_entries if lorebook_entries else None
+                    scenario_context="Playing a game of chess"
                 )
-                
+
                 # Validate response
                 if not isinstance(resp, str):
                     resp = str(resp)
-                if len(resp.strip()) < 10:
-                    from response_generator import generate_emergency_response
-                    resp = generate_emergency_response(current_char, other_char, history, {}, turn)
-                
-                history.append({'name': current_char['name'], 'content': resp})
+
+                chess_history.append({'name': current_char['name'], 'content': resp})
                 print(resp)
-                
-                # Switch characters (cycle through all characters)
-                other_char_index = current_char_index
-                current_char_index = (current_char_index + 1) % len(characters)
-                
-                # Delay before next turn
-                if turn < args.max_turns:
-                    print(f"\n‚è≥ Waiting {args.delay} seconds...")
-                    time.sleep(args.delay)
-                    
+
+                # Parse the JSON response
+                dialogue, move_notation, board_state = parse_chess_json_response(resp, current_char['name'])
+
+                if dialogue:
+                    print(f"üí¨ Dialogue: {dialogue}")
+
+                # Attempt to make the chess move if notation is provided
+                if move_notation:
+                    # Try to parse the move notation
+                    success, from_pos, to_pos = parse_move_notation(move_notation, chess_game, current_player_color)
+
+                    if success and from_pos and to_pos:
+                        move_success = chess_game.make_move(from_pos, to_pos)
+                        if move_success:
+                            print(f"‚úÖ Move successfully made: {chess_game.move_history[-1] if chess_game.move_history else move_notation}")
+                            return True, turn + 1  # Move was successful, return incremented turn
+                        else:
+                            print(f"‚ùå Move failed - illegal move attempted: {move_notation}")
+                            # Add feedback to history
+                            feedback = f"Your move '{move_notation}' was invalid or illegal. Please try again with a valid chess move from the current position."
+                            chess_history.append({'name': 'Referee', 'content': feedback})
+                            return False, turn + 1  # Move failed, but return incremented turn
+                    else:
+                        print(f"‚ùå Could not parse move notation: {move_notation}")
+                        # Add feedback to history
+                        feedback = f"I couldn't parse the move '{move_notation}'. Please provide a valid chess move in algebraic notation."
+                        chess_history.append({'name': 'Referee', 'content': feedback})
+                        return False, turn + 1  # No valid move, increment turn
+                else:
+                    print(f"‚ö†Ô∏è  No move provided. Current player: {current_player_color}")
+                    # Add feedback to history
+                    feedback = f"Please provide a valid chess move in your response."
+                    chess_history.append({'name': 'Referee', 'content': feedback})
+                    return False, turn + 1  # No move provided, increment turn
+
             except KeyboardInterrupt:
                 print("\n‚ö†Ô∏è  Interrupted by user. Saving...")
-                break
-                
+                return None, turn  # Return None to indicate interruption
+
             except Exception as e:
                 print(f"\n‚ùå Error on turn {turn}: {e}")
                 import traceback
                 traceback.print_exc()
-                
+
                 # Generate fallback response
                 from response_generator import generate_emergency_response
-                fallback_resp = generate_emergency_response(current_char, other_char, history, {}, turn)
-                history.append({'name': current_char['name'], 'content': fallback_resp})
+                fallback_resp = generate_emergency_response(current_char, other_char, chess_history, {}, turn)
+                chess_history.append({'name': current_char['name'], 'content': fallback_resp})
                 print(fallback_resp)
-                
-                # Switch characters (cycle through all characters)
-                other_char_index = current_char_index
-                current_char_index = (current_char_index + 1) % len(characters)
-                continue
+                return False, turn + 1
+
+
+        else:  # Normal conversation mode
+            # Main conversation loop
+            for turn in range(start_turn, args.max_turns + 1):
+                print(f"\n{'='*80}")
+                print(f"[TURN {turn}] {characters[current_char_index]['name']}")
+                print('='*80)
+
+                try:
+                    # Get current and other characters
+                    current_char = characters[current_char_index]
+                    other_char = characters[other_char_index]
+
+                    # Determine current scenario context (default to args.scenario or enhanced if progression exists)
+                    current_scenario = args.scenario
+                    if scenario_progressor:
+                        # Always use the latest scenario context from progressor if available
+                        current_scenario = scenario_progressor.get_scenario_context_for_stage()
+
+                    # Check for scenario progression
+                    scenario_progression_message = ""
+                    if scenario_progressor:
+                        scenario_progression_message = check_scenario_progression(scenario_progressor, history, turn)
+                        if scenario_progression_message:
+                            print(f"üöÄ SCENARIO PROGRESSION: {scenario_progression_message}")
+                            # Add scenario progression to history as a narrative element
+                            history.append({'name': 'Narrator', 'content': scenario_progression_message})
+                            # Update the scenario context for this turn and for future turns
+                            current_scenario = scenario_progressor.get_scenario_context_for_stage()
+                            args.scenario = current_scenario  # Update the main scenario for future use
+                            print(f"üìä Updated scenario context: {scenario_progressor.get_current_stage_description()}")
+
+                    # Extract lorebook entries based on scenario keywords
+                    lorebook_entries = []
+                    if current_scenario:  # Use current_scenario which may be updated by progression
+                        from character_loader import extract_lorebook_entries
+                        # Search for keywords in scenario that match character lorebooks
+                        scenario_keywords = current_scenario.lower().split()
+                        for char in characters:
+                            entries = extract_lorebook_entries(char['raw_data'], history, max_entries=2)
+                            # Filter entries by scenario relevance
+                            relevant_entries = []
+                            for entry in entries:
+                                if any(keyword in entry.lower() for keyword in scenario_keywords if len(keyword) > 3):
+                                    relevant_entries.append(entry)
+                            lorebook_entries.extend(relevant_entries[:1])  # Add at most 1 relevant entry per character
+
+                    resp = generate_response_adaptive(
+                        current_char, other_char, history, turn,
+                        enable_environmental=not args.no_environmental,
+                        similarity_threshold=args.similarity,
+                        verbose=args.verbose,
+                        scenario_context=current_scenario,
+                        lorebook_entries=lorebook_entries if lorebook_entries else None
+                    )
+
+                    # Validate response
+                    if not isinstance(resp, str):
+                        resp = str(resp)
+                    if len(resp.strip()) < 10:
+                        from response_generator import generate_emergency_response
+                        resp = generate_emergency_response(current_char, other_char, history, {}, turn)
+
+                    history.append({'name': current_char['name'], 'content': resp})
+                    print(resp)
+
+                    # Switch characters (cycle through all characters)
+                    other_char_index = current_char_index
+                    current_char_index = (current_char_index + 1) % len(characters)
+
+                    # Delay before next turn
+                    if turn < args.max_turns:
+                        print(f"\n‚è≥ Waiting {args.delay} seconds...")
+                        time.sleep(args.delay)
+
+                except KeyboardInterrupt:
+                    print("\n‚ö†Ô∏è  Interrupted by user. Saving...")
+                    break
+
+                except Exception as e:
+                    print(f"\n‚ùå Error on turn {turn}: {e}")
+                    import traceback
+                    traceback.print_exc()
+
+                    # Generate fallback response
+                    from response_generator import generate_emergency_response
+                    fallback_resp = generate_emergency_response(current_char, other_char, history, {}, turn)
+                    history.append({'name': current_char['name'], 'content': fallback_resp})
+                    print(fallback_resp)
+
+                    # Switch characters (cycle through all characters)
+                    other_char_index = current_char_index
+                    current_char_index = (current_char_index + 1) % len(characters)
+                    continue
         
         # Save and analyze
         save_conversation(history, output_file)
